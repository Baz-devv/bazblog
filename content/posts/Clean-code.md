---
title: "Clean Code"
date: 2024-01-09T14:57:35+03:00

---
[![Clean code uncle bob](https://images-na.ssl-images-amazon.com/images/I/51E2055ZGUL._AC_UL210_SR210,210_.jpg)]

Link: https://www.amazon.com/Clean-Code-Handbook-Software-Craftsmanship/dp/0132350882

Many a developer preach the gospel of clean code but how many have actually read the book? Granted this book isn't the be all end all of clean-code but it's definitely the industry standard.

As the book alludes to, there are developers with 'code-sense' who are able to pick up clean-code naturally while some of us have to acquire it the hard-way, we put ourselves through a Rocky like training 
of constantly reading, writing and refactoring code in order to get it to the accepted industry standards and as you probably might know programmers are a difficult bunch to please so I guess it's a hopeless task.. 

This is my chapter by chapter summary of Clean Code by Robert Martin(Uncle Bob), some parts verbatim others not so much. I hope at the end I'll be well on my way to acquiring 'code-sense'.


## CHAPTER 1: CLEAN CODE.

I just have to get this out of the way first, "The only valid measurement of code quality: WTFs/minute."

#### There will be code.

There's always talk of will there be need for programmers in the future or will there be machines to replace them? Well this author believes good-programmers will always be needed and in demand but 
I bet he to is feeling the heat generated by AI, advancements in this field surely cannot be ignored but we embrace it not fear it.

#### Bad code

Bad code has the effect of slowing down teams and reducing productivity, if you understand the butterfly effect, you'll agree when someone says bad code could bring organisations to their knees, more on this
later.

WADING => The act of being impeded by bad code.

#### The total cost of owning a mess.

As the mess(bad code) builds, the productivity continues to decrease, asymptomatically approaching zero and as this happens, management does the only thing they can, add more staff with hope that productivity
picks up but we know to well it won't as they haven't addressed the underlying issue. I hope you can now start seeing the cost of the mess in tangible detail.

#### The grand redesign in the sky.

Let's build a new sytem to replace this new one. We'll use a new flashy language that the programmers now have to pick up, dangle all the trendy tech buzzwords to management so they allow a redesign and promise
heaven on earth with the new system. 

Every programmer gets to experience the above scenario a few times in their career. The team lead probably convinced you the switch from JavaScript to Rust is beacause Rust is blaingly fast and you ate up that 
lie with glee.

The truth of the matter is that your current system has bad code, don't get me wrong rust is way faster than js, so every few years you'll always find yourself redesigning instead maintaining good code and the
cycle of bad code continues.

Spending time keeping your code clean isn't just cost effective, it's a matter of professional survival.

#### Attitude.

Why does good code rot so quickly into bad code?


To list a few reasons:
1. complaints that requirements changed in ways that thwart the original design.
2. complaints that schedules were to tight to do things right.

These are just excuses, programmers are deeply complicit in the planing of the project and share a great deal of the responsibility for any failures.

#### The primal conundrum.
The only way to make the deadline - the only way to go fast - is to keep the code as clean as possible at all times.

#### The art of clean code.
How do I write clean code?

Well first you must know what it means for code to be clean.

This really hurt my pride a bit "being able to recognize clean code from dirty code doesn't mean we know how to write clean code". A programmer who writes clean code is an artist who can take a blank screen 
through a series of transformations until it is an elegant coded system.

The author gave us a peak into what programming pioneers and experts think about clean code, here are a few that stuck with me:

Bjarne Stroustrup:

`I like my code to be elegant and efficient. The logic should be straightfoward to make it hard for bugs to hide, the dependencies minimal to ease maintenance, error-handling complete according to an articulated
strategy, and perfomance close to optimal so as not to tempt people to make the code messy with unprincipled optimizations. Clean code does one thing well.`

Grady Booch:

`Clean code is simple and direct. Clean codenever obscures the designer's intent but rather is full of crisp abstractions and straightfoward lines of control.`

But personally the best description of what clean code ought to look like that has always stuck with me is `...Clean code always looks like it was written by someone who cares...` by Michael Feathers.


## CHAPTER 2: MEANINGFUL NAMES.

Here are the rules mentioned in the book for defining names, I won't go into detail as the purpose here is to summarize:

1. Use intention revealing names.

2. Avoid disinformation.

3. Make meaningful distinctions.

4. Use pronounceable names.

5. Use searchable names.

6. Avoid encodings.

7. Avoid mental mapping.

8. Don't be cute.

9. Pick one word per concept.

10. Don't pun.

11. Use solution domain names.

12. Use problem domain names.

13. Add meaningful context.

14. Don't add gratuitous context.

## CHAPTER 3: FUNCTIONS.

What is it that makes a function easy to read and understand? How can we make a function communicate its intent?

Well here are a few guidelines:

#### Small!
The first rule of functions is that they should be small. The second rule is that they should be smaller than that.
Not set in stone but it's just a good idea not to have your functions more than 20 lines long if you've had to read bad code you definitely agree with this.

#### Blocks and Indenting.
Functions shouldn't be large enough to hold nested structures. The indent level of a function should not be more than 2.

#### Do One Thing.
`Functions should do one thing. They should do it well. They should do it only.`

If a function does things that are one level below the stated name of the function then it's doing one thing.

*A way of knowing whether a function is doing more than 'one thing' is if you can extract another function from itwith a name that is not merely a restatement of its implementation.

#### Sections With Functions.
Functions that do one thing cannot be reasonably divided into sections.

#### One Level Of Abstraction Per Function.
Make sure that the statements within your functions are all at the same level of abstraction.

#### Reading Code From Top To Bottom: `The Stepdown Rule`.
Code ought to read like a top-down narrative, remember that 'well-written prose' description?

Every function should be followed by those at the next level of abstraction so that we can read the program, descending one level of abstraction at a time.

#### Use Descriptive Names.
As already pointed out, meaningful names are a godsend in programming.

The smaller and more focused a function is, the easier it is to choose a descriptive name.

#### Function Arguments.
The ideal number of arguments for a function is niladic. Next comes monadic followed by dyadic.

Triadic functions should be avoided where possible.

#### Common Monadic Forms.
There are 2 very common reasons to pass a single argument into a function:
1. you may be asking a question about that argument.

2. you may be operating on that argument.

#### Dyadic Functions.
A function with two arguments is harder to understand than a monadic function.

#### Triadic Functions.
Abundantly difficult than dyads. The issues of ordering, pausing and ignoring are more than doubled.

#### Argument Objects.
When a function needs more than 2 arguments, it's clear that some of those arguments need to be wrapped in a class of their own.

#### Output Arguments.
In general, output arguments should be avoided. If your function must change the state of something, have it change the state of its owning object.

#### Prefer Exceptions To Returning Error Codes.
Returning error codes from command functions is a subtle violation of command query separation.

It promotes commands being used as expressions in the predicates of `if` statements.

#### Extract `try/catch` Blocks.
`try/catch` blocks are ugly, let's get that out of the way first.

They confuse the structure of the code and and mix error processing with normal processing.

It's therefore better the bodies of `try/catch` blocks out into functions of their own.

#### Error Handling Is One Thing.
Functions should do one thing. Error handling is one thing. Thus, a function that handles errors should do nothing else.

#### How do you write perfect functions?
The only way is to first write bad functions, then re-write and refactor them until you have a clean function. You probably won't get it right at the first try.

`Master programmers think of systems as stories to be told rather than programs to be written.`

## CHAPTER 4: COMMENTS.

`"Don't comment bad code - rewrite it" Brian Kernighan`

The proper use of comments is to compensate for our failure to express ourselves in code.

Comments are a necessary evil. In a perfect universe, code should be clear and expressive that it doesn't need comments.

Always keep in mind though that the truth can only be found in one place; `the code`.

#### Comments Do Not Make Up For Bad Code.
Clear and expressive code with few comments is far superior to cluttered and complex code with lots of comments.

Rather than spending time writing comments explaining your bad code, spend it cleaning the mess.

#### Explain Yourself In Code.
It takes only a few seconds of thought to explain most of your intent in code. In many cases, it's simply a matter of creating a function that says the same thing as the comment you want to write.

#### Good Comments.
Some comments are good but keep in mind that the only truly good comment is the comment you found a way not to write.

Here are a few reasons for writing comments and the laws they should abide by:

##### 1.Legal Comments.
Sometimes our corporate coding standards force us to write certain commentsfor legal reasons.

##### 2.Informative Comments.
It is SOMETIMES useful to provide basic information with a comment.

##### 3.Explanations Of Intent.
Sometimes a comment goes beyond just useful information about the implementation and provides the intent behind a decision.

##### 4.Clarification.
Sometimes it's just helpful to translate the meaning of some obscure argument or return value into something that's readable. It's better to find a way to make that argument or return value clear in its
own right; but when it's part of the standard library or in code you can't alter then a helpful clarifying comment can be useful.

##### 5.Warning Of Consequence.
We may use comments to warn other programmers about certain consequences.

##### 6.TODO Comments.
It's reasonable to leave 'To Do' notes in the form of `//TODO` comments.

##### 7.Amplification.
A comment may be used to amplify the importance of something that may otherwise seem inconsequential.

#### Bad Comments.
Most comments fall into this category. Usually they are crutches for poor code or justifications for insufficient decisions amounting to little more than the programmer talking to himself.

What constitutes a bad comment?

##### 1.Mumbling.
If you decide to write a comment, then spend the time necessary to make sure it is the best you can write anything less is just negligence and bad programming.

##### 2.Redundant Comments.
Don't write comments that obscure the code.

##### 3.Misleading Comments.
Sometimes with all the best intentions, a programmer makes a statement in his comments that isn't precise enough to be accurate.

##### 4.Mandated Comments.
It is plain silly to have a rule that every function or variable must have a comment. Such restrictions cause comments to clutter up code, propagate lies and lend to general confusion and disorganization.

##### 5.Journal Comments.
Journal comments should be removed or they'll add up to one giant mess.

##### 6.Noise Comments.
Sometimes you'll see comments that are nothing but noise. They restate the obvious and provide no new information.

Replace the temptation to create noise with the determination to clean your code.

##### 7.Don't Use A Comment When You Can Use A Function Or A Varable.

##### 8.Position Markers.
`////////////` are really an eyesore.

They are clutter that should be eliminated.

##### 9.Closing Brace Comments.
Don't put comments at the end of closing braces.

##### 10.Attributions And Bylines.
Just don't do it.

##### 11.Commented-out Code.
Instead of commenting-out code, delete it.

##### 12.HTML Comments.
HTML in source code comments is an abomination.

##### 13.Nonlocal Information.
If you must write a comment, make sure it describes the code it appears near. Don't offer systemwide information in the context of a local comment.

##### 14.Too Much Information.
Don't put interesting historical discussions or irrelevant descriptions of details into your comments.

##### 15.Inpbvious Behaviour.
The connection between a comment and the code it describes should be obvious. The purpose of a comment is to explain code that does not explain itself.

`IT IS A PITY WHEN A COMMENT NEEDS ITS OWN EXPLANATION.`

##### 1.Function Headers.
Short functions don't need much description. A well chosen name for a small function that does one thing is usually better than a comment header. 
